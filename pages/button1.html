<p>MySQL has become very popular in the database world. With tons of third party GUI applications, an extensive collection of tutorials, and many well-known websites using it, it has almost become the number one database engine[1]! On this page we will try to find out why MySQL has become so popular.<p>
<div class="expandable" id="Origin">
    <p>MySQL started as in improvement to the mSQL system. mSQL was based on ISAM, a low-level language which many developers weren’t satisfied with. Developers found it slow and very hard to work with. A solution had to be made, and that solution was MySQL. In 1994 two swedish programmers started working on a project that would replace mSQL. In 1995 the first version was released: It was a huge success. They implemented the same API as mSQL, so many developers could still use their source code without any modifications when making the transition from mSQL to MySQL. mSQL had a very expensive license, and MySQL was just as easy to use for free.</p>
</div>

<div class="expandable" id="Expansion and success">
    <p>Many developers described MySQL as “immature”. However, MySQl was very lightweight and easy to set up. You could have your engine running in no-time, while other “mature” engines sometimes took ages to set up. MySQL was perfect for the purposes that didn’t require very advanced features, because of it’s easy use. After the first release MySQL grew quite quickly. Around 2003 MySQL Inc decided that they wanted to take MySQL into a different direction. They wanted to turn MySQL into a mature RDBMS (Relational Database Management System). With each version they implemented more features that were considered essential to a relational database. With this development MySQL became more multi-purposed, and caught the attention of a wider audience. In 2008 Sun Microsystems bought MySQL, greatly expanding the development team. Sun had a huge budget, so MySQL grew like never before. While under the control of Sun MySQL gained many important features such as the event scheduler, partitioning, an API for plugins and server logging. In 2010 Oracle acquired Sun Microsystems and thus MySQL. Nowadays MySQL implements a broad range of features and supports almost all major operating systems, making it a first choice for many developers. MySQL has become the M in “LAMP”. LAMP stands for "Linux, Apache, MySQL, PHP", and LAMP is a very popular choice of setup for a website.</p>
</div>

<div class="expandable" id="Features">
    <p>MySQL now implements almost every feature a developer could ask for. MySQL implements almost every aspect of the SQL language. A few features of the SQL standard are not available in MySQL, or are a little different[2]. This is mostly to avoid performance issues that would have occurred when the SQL standard was followed. MySQL allows extensions, which means the SQL language can be adapted to the need of the user.</p>
</div>

<div class="expandable" id="Safety">
    <p>MySQL fully implements the ACID principle. ACID stands for Atomicity, Consistency, Isolation and Durability. Acid is a set of requirements that, together, guarantee that database transactions are processed reliably. A transaction, such as reading data, writing data or modifying data can have impact on the real world, and therefore it is of great importance that every transaction is processed reliably. If a problem occurs when transferring money in a webshop, the order could be delivered without the money being transferred.
Atomicity is the requirement that a transaction happens as a whole, or doesn’t happen at all. For example, a transaction could be to transfer 5 dollars from bank accounts A to B. First the money is withdrawn from A, then added to B. If the transaction doesn’t happen as a whole, the money is withdrawn from A, but not added to B. Atomicity requires the money to successfully transfer, or not transfer at all.
Consistency is a requirement that makes sure that, after a transaction, the database is still completely valid. The validation of a database can be defined by things such as constraints, cascades and triggers. A constraint may be that a customer can never reach an age over 150. If a transaction updates the age of a customer to a value greater than 150, the constraint is broken, and the database is not valid anymore. Consistency ensures that the transaction is cancelled and reversed if it results in invalidity in the database.
Isolation is a requirement that when two transactions are executed concurrently (at the same time), the result is exactly the same as if these two transactions were executed after each other. 
Durability is the requirement that, once a transaction is completed, it will never be undone. Even in the event the server crashes, power fails or something else happens. When a transaction is marked as completed, it is “safe”. As far as software goes, of course, MySQL cannot prevent the server machine room from flooding or exploding. MySQL does, however, allow Shared-nothing clustering. This means that data can be spread across multiple storages, and if one of these disks fails, not all data is lost. More about clustering in the scalability section.<p>
</div>

<div class="expandable" id="Scalability">
    <p>MySQL is very good at scaling. It has no limit on the maximum size of the database. Many other database engines have a limit to how big the database can become. While many of these limits are very high (ranging from 2GB to 128PB), having no limits is always better. MySQL does, however, have a limit on how big one table can be. When using Innodb (the default storage engine) one table cannot exceed 64TB. Such numbers will rarely be achieved, and through clustering, unlimited sized tables can be achieved. Clustering is a technique where the workload can be distributed over many machines, making the task easier to cope with. In our case, calculation wise the task is easy, so the main reason to apply clustering is to share disk space. MySQL Cluster is an architecture that is fully ACID compliant, which means it’s safe to use. Any transaction applied on the clustered database is just as safe as a transaction on the single-storage database. It is also designed to have no bottlenecks or weak spots. Any node in the architecture can fail, without the entire system failing. This is a huge plus, because it greatly improves the uptime of the database system. In case of a failure, the data stored on that node is not completely lost. Because of replication, there are always two instances of the data available in the cluster. If one node fails, the replica can be retrieved from another node to still properly execute queries. This is achieved through synchronous replication. Synchronous replication is a technique where every block of data is written on an atomic way on both disks. This means that the write operation either completes on both disks, or doesn’t complete at all. This guarantees zero data loss, but it creates quite a delay when writing data. To ensure that all data is written twice successfully, two-phase commitment is used. Two-phase commitment is a protocol that allows a transaction to be executed on multiple machines. One machine acts as a coordinator. As the name suggests, the protocol is split up in two phases: the request phase and the commit phase. In the request phase the coordinator sends out a query to all involved machines and waits. Each machine executes the order up to the point where they have to commit (usually the last step, after a commit the action cannot be undone.) Each machine keeps logs of their actions. Then the second phase begins. Each machine then sends a vote to the coordinator if they want to continue with the transaction. If the coordinator receives a positive vote from all machines the coordinator sends a commit order to all machines. The machines all commit the transaction (which means it has been written to the disk) and send an acknowledgement to the coordinator. If the coordinator receives an acknowledgement from all machines the transaction has been completed successfully.
If the coordinator receives a negative vote in the second phase, or doesn’t receive a vote at all (after a timeout, for example) the coordinator sends a rollback order to all machines. Instead of committing the transaction, they undo it. This is why each machine carefully keeps logs of their actions. These logs can be used to undo a transaction. Then each machine sends an acknowledgement that they have successfully undone the transaction. Through this protocol a transaction is never done on only one machine.
(http://sardes.inrialpes.fr/~krakowia/MW-Book/Chapters/Transact/Chapters/Transact/Figs/two-pc.gif)
Because of the replication data can be recovered within the network. If one machine fails permanently, for example, when a disk crash occurs, the data on that disk is still available within the clustered network. The data that was originally on that machine can be derived from the data in the network, since every block of data should be available twice. This shows that clustering is not only a way to share storage load, but also a way to provide safety and durability of data. Next to deriving the data every machine also keeps track of redo-logs. With these logs every action can be tracked back. These logs are written asynchronously, a few seconds after each transaction. If the redo logs were written synchronously data loss would be completely out of the question, but also cause a much greater delay. Since a failure of the entire network is very, very unlikely there is no need to write these logs synchronously.
Due to the logs being written asynchronously small amounts of data can actually be lost if the entire network fails simultaneously, this can be prevented easily by spreading the machines over multiple buildings and locations, instead of putting the entire clustered network in one server room.
By default the data is distributed over the machines through a hashing algorithm based on the PRIMARY KEY. Users can, however, define their own way of distributing the data. This way the developer gets control over which data is stored where. This is useful to improve speed in some cases where frequently used data is grouped together. This is a principle very much similar to disk fragmentation[3].
What makes MySQL Cluster so great is that querying is completely transparent for the application layer. Even though data may be spread over multiple machines, the application notices no difference in the way it queries. Every bit of management is done “behind the scenes”, the application doesn’t know if it’s communicating with a single-storage server or a clustered server.<p>
</div>

<div class="expandable" id="Secuirity">
   <p> MySQL offers a huge documentation[4] about security on their website. This documentation mentions commonly made mistakes, extensive guides on how to secure your server and documentation about the built-in privilege system. Natively, MySQL supports a secure SSL connection between the client and server. By default, however, MySQL doesn’t encrypt the connection with the client. Since usually the server and the client run on the same machine, a secure connection is redundant. However, there are some cases where a secure connection is desired, and in those cases SSL can easily be turned on. 
The privilege system that comes with MySQL is very powerful. It allows the administrator to create and manage user accounts. While it is uncommon to allow direct access to the database, the privilege system can be very useful to restrict access of certain applications. You may, for example, have a separate user application and an administrator application. The user application is available publicly, and could be tempered with. By creating a new account for the user application, and restricting its rights on the server, the administrator can ensure that, even though the user application is vulnerable, the server is still safe.<p>
</div>

<div class="expandable" id="Applicable scenarios and conclusion">
    <p>MySQL has proven to be very widely applicable. From small applications to huge projects, MySQL scales perfectly to fit the needs of the developer. It’s easy to set up and get going quickly, so for a small project MySQL is an excellent choice. For bigger projects MySQL takes a bit more effort to set up, but it’s worth the time investment, clustering is done very neatly and secure, and also allows for quick expansion. For a project that is expected to start small and grow big MySQL is also a perfect choice to go with. When the project gets too big you can go from a single-storage server to a clustered architecture without having to change a single line of code in the application. MySQL also has a great collection of things to offer when it comes to security, reliability and durability. MySQL is an overall top-performer and deserves it’s place at the top.</p>
</div>